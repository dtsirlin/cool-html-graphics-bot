// Generated by CoffeeScript 1.6.3
/*
  Author: Chris Shier, http://csh.bz
  Date: September 7th, 2013
*/


(function() {
  var PI, animloop, canvas, contrast, cos, ctx, cycle, decay, fps, fpsFilter, fps_now, frames, hsl2rgb, imageSmoothing, lastUpdate, last_scaling, rainbow, random_seed, random_seed2, rgb2hsl, scaled_count, scaling, shrink, shrinkCanvas, sin, sizeCanvasesToWindow, vis_canvas, vis_ctx;

  canvas = document.createElement('canvas');

  ctx = canvas.getContext('2d');

  vis_canvas = document.getElementById('canvas');

  vis_ctx = vis_canvas.getContext('2d');

  shrink = 3;

  shrinkCanvas = function(shrink) {
    canvas.width = window.innerWidth / shrink | 0;
    return canvas.height = window.innerHeight / shrink | 0;
  };

  shrinkCanvas(shrink);

  sizeCanvasesToWindow = function(event, context, zoom) {
    var canvasCopy, contextCopy, d, e, g, height, oh, ow, w, width;
    if (context == null) {
      context = ctx;
    }
    if (zoom == null) {
      zoom = 1;
    }
    w = window;
    d = document;
    e = d.documentElement;
    g = d.getElementsByTagName('body')[0];
    width = w.innerWidth || e.clientWidth || g.clientWidth;
    height = w.innerHeight || e.clientHeight || g.clientHeight;
    ow = context.canvas.width;
    oh = context.canvas.height;
    canvasCopy = document.createElement('canvas');
    contextCopy = canvasCopy.getContext('2d');
    canvasCopy.width = ow;
    canvasCopy.height = oh;
    contextCopy.drawImage(context.canvas, 0, 0);
    context.canvas.width = width / zoom;
    context.canvas.height = height / zoom;
    context.drawImage(canvasCopy, 0, 0, width / zoom, height / zoom);
    context.canvas.style.zoom = zoom;
    context.canvas.style.MozTransformOrigin = "0 0";
    return context.canvas.style.MozTransform = "scale(" + zoom + ", " + zoom + ")";
  };

  sizeCanvasesToWindow(null, vis_ctx, 1);

  fps = 0;

  fps_now = null;

  lastUpdate = Date.now() * 1 - 1;

  fpsFilter = 50;

  scaling = 1;

  last_scaling = 1;

  scaled_count = 0;

  setInterval((function() {
    scaling = (60 / fps * 10 | 0) / 10;
    if (scaling > 2) {
      scaling = 2;
    }
    if (last_scaling !== scaling && (1 <= scaling && scaling <= 2) && scaled_count < 6) {
      console.log("" + (fps | 0) + "fps, " + scaling + " zoom, " + (scaled_count + 1) + " of 6");
      sizeCanvasesToWindow(null, vis_ctx, scaling);
      last_scaling = scaling;
      return scaled_count += 1;
    }
  }), 3000);

  window.addEventListener('resize', (function() {
    shrinkCanvas(shrink);
    return sizeCanvasesToWindow(null, vis_ctx, 1);
  }), false);

  window.addEventListener('onorientationchange', (function() {
    shrinkCanvas(shrink);
    return sizeCanvasesToWindow(null, vis_ctx, 1);
  }), false);

  window.addEventListener('resize', (function() {
    return scaled_count = 0;
  }), false);

  window.addEventListener('onorientationchange', (function() {
    return scaled_count = 0;
  }), false);

  frames = 0;

  PI = Math.PI;

  sin = function(angle) {
    return Math.sin(angle);
  };

  cos = function(angle) {
    return Math.cos(angle);
  };

  imageSmoothing = function(context, a) {
    if (context == null) {
      context = ctx;
    }
    if (a == null) {
      a = false;
    }
    context.webkitImageSmoothingEnabled = a;
    context.mozImageSmoothingEnabled = a;
    return context.imageSmoothingEnabled = a;
  };

  rainbow = function(angle, alpha, offset) {
    var a, b, g, r;
    if (angle == null) {
      angle = 1;
    }
    if (alpha == null) {
      alpha = 1;
    }
    if (offset == null) {
      offset = 1;
    }
    r = 128 + 127 * sin(angle + 0 * PI / 3 * offset);
    g = 128 + 127 * sin(angle + 2 * PI / 3 * offset);
    b = 128 + 127 * sin(angle + 4 * PI / 3 * offset);
    a = alpha;
    return "rgba(" + (r | 0) + "," + (g | 0) + "," + (b | 0) + "," + a + ")";
  };

  decay = function(h, v, s, r) {
    var dh, dw, dx, dy;
    ctx.save();
    ctx.translate(canvas.width / 2 + h, canvas.height / 2 + v);
    if (r !== 0) {
      ctx.rotate(r);
    }
    dx = -(canvas.width + s) / 2;
    dy = -(canvas.height + s) / 2;
    dw = canvas.width + s;
    dh = canvas.height + s;
    ctx.drawImage(canvas, dx, dy, dw, dh);
    return ctx.restore();
  };

  rgb2hsl = function(r, g, b) {
    var d, h, l, max, min, s;
    r /= 255;
    g /= 255;
    b /= 255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
      }
      h /= 6;
    }
    return [h, s, l];
  };

  hsl2rgb = function(h, s, l) {
    var b, g, hue2rgb, p, q, r;
    if (s === 0) {
      r = g = b = l;
    } else {
      hue2rgb = function(p, q, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
          return q;
        }
        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
      };
      q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return [r * 255, g * 255, b * 255];
  };

  contrast = function(context) {
    var d, i, max, min, multiplier, n, sum;
    d = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
    n = 0;
    min = 10;
    max = 240;
    multiplier = 1.009;
    while (n < d.width * d.height) {
      i = n * 4;
      sum = d.data[i] + d.data[i + 1] + d.data[i + 2];
      d.data[i + 0] = d.data[i + 0] * multiplier % 255;
      d.data[i + 1] = d.data[i + 1] * multiplier % 255;
      d.data[i + 2] = d.data[i + 2] * multiplier % 255;
      if (sum < 12 || sum > 760) {
        d.data[i + 3] = 0;
      }
      n++;
    }
    return context.putImageData(d, 0, 0);
  };

  cycle = function(context) {
    var d, hsl, i, n, rgb;
    d = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
    n = 0;
    while (n < d.width * d.height) {
      i = n * 4;
      hsl = rgb2hsl(d.data[i], d.data[i + 1], d.data[i + 2]);
      rgb = hsl2rgb((hsl[0] + 3 / 360) % 1, 1, 0.498);
      d.data[i] = rgb[0];
      d.data[i + 1] = rgb[1];
      d.data[i + 1] = rgb[2];
      n++;
    }
    return context.putImageData(d, 0, 0);
  };

  random_seed = (Math.random() - 0.5) * 2 * PI;

  random_seed2 = Math.random() - 0.5;

  ctx.fillStyle = rainbow(PI / 2 + random_seed, 1, 1);

  ctx.beginPath();

  ctx.arc(canvas.width / 2, canvas.height / 2, 16, 0, 2 * PI, false);

  ctx.closePath();

  ctx.fill();

  (animloop = function() {
    var animloop_id, horizontal, rotation, spread, thisFrameFPS, vertical;
    animloop_id = requestAnimationFrame(animloop);
    thisFrameFPS = 1000 / ((fps_now = Date.now()) - lastUpdate);
    fps += (thisFrameFPS - fps) / fpsFilter;
    lastUpdate = fps_now;
    frames += 1;
    ctx.fillStyle = rainbow(frames / 512 + PI + random_seed, 1, 1);
    ctx.fillRect(0, 0, canvas.width, 1);
    ctx.fillRect(canvas.width - 1, 0, 1, canvas.height);
    ctx.fillRect(0, canvas.height - 1, canvas.width, 1);
    ctx.fillRect(0, 0, 1, canvas.height);
    horizontal = -1 / 9 * sin(frames / 1112 - random_seed) / last_scaling / shrink;
    vertical = 1.3 + sin(frames / 400) / 3 / last_scaling / shrink;
    spread = 2.5 - 3 / 2 * sin(frames / 301) / shrink;
    rotation = -1 / 361 * sin(frames / 1600 + PI - random_seed2);
    decay(horizontal, vertical, spread, rotation);
    horizontal = 1 / 9 * sin(frames / 1111 + random_seed) / last_scaling / shrink;
    vertical = -1.7 - sin(frames / 399) / 2.5 / last_scaling / shrink;
    spread = -2 + 1 / 2 * sin(frames / 311) / shrink;
    rotation = 1 / 360 * sin(frames / 1600.3 + PI + random_seed2);
    decay(horizontal, vertical, spread, rotation);
    cycle(ctx);
    contrast(ctx);
    decay(sin(frames / 411) / 1.75 / last_scaling, cos(-frames / 411 + PI / 2) / 1.75 / last_scaling, 0, 0);
    imageSmoothing(vis_ctx, false);
    return vis_ctx.drawImage(canvas, 0, 0, vis_canvas.width, vis_canvas.height);
  })();

}).call(this);

/*
//@ sourceMappingURL=paddles.map
*/
